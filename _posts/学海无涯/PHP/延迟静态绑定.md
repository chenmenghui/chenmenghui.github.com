---
title: 延迟静态绑定
date: 2019-2-13
categories: 
- PHP
tags: 
- PHP
---

后期静态绑定，用于在继承范围内引用静态调用的类。

后期静态绑定工作原理是存储了在上一个“非转发调用”（non-forwarding call）的类名。当进行静态方法调用时，该类名即为明确指定的那个（通常在 :: 运算符左侧部分）；当进行非静态方法调用时，即为该对象所属的类。所谓的“转发调用”（forwarding call）指的是通过以下几种方式进行的静态调用：self::，parent::，static:: 以及 forward_static_call()。可用 get_called_class() 函数来得到被调用的方法所在的类名，static:: 则指出了其范围。

转发调用:
self:: 所在类
parent:: 父类
static:: 调用类

后期静态绑定的解析会一直到取得一个完全解析了的静态调用为止。另一方面，如果静态调用使用 parent:: 或者 self:: 将转发调用信息

```php
<?php

class A
{
    public static function foo()
    {
        static::who(); // 留意此处,static究竟指向谁
        // 如果是self::who(),就都是A了.这就是特别需要注意的地方
    }

    public static function who()
    {
        echo static::class;
        echo __CLASS__ . "\n";
    }
}

class B extends A
{
    public static function test()
    {
        A::foo(); // 非转发调用
        static::foo();
        parent::foo(); //
        self::foo();
    }

    public static function who()
    {
        echo static::class;
        echo __CLASS__ . "\n";
    }
}

class C extends B
{
}

C::test();

?>
```

运行结果
```
AA
CB
CB
CB
```

对于方法who()中
static::class是调用类的类名 
__CLASS__是对象实例所属类的类名

个人对运行结果的看法

第一个AA
    1. C::test() => C->B::test(){A::foo()}
    2. A::foo(){static::who()} => A::who()

第二个CB
    1. C::test() => C->B::test(){*static::foo()*}
    2. C->B::test(){static::foo()} => C->B->A::foo(){static::who()} = C::who() = C->B::who() # 类C没有foo,所以向最近的被继承类中找
    
第三个CB
    1. C::test() => C->B::test(){*parent::foo()*}
    2. C->B->A::foo(){static::who()} => C->B::who() # 直接找类A中的foo

第三个CB
    1. C::test() => C->B::test(){*self::foo()*}
    2. C->B->A::foo(){static::who()} => C->B::who() # 类B没有foo,所以向最近的被继承类中找
